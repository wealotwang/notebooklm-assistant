# Google AI Companion: 项目全景复盘与技术白皮书

本文档是对 Google AI Companion 项目（原 NotebookLM 文件夹工具）的深度客观复盘。它记录了从 MVP 原型到跨平台（NotebookLM & Gemini）深度融合过程中的核心决策、技术攻坚及经验教训。

---

## 📅 核心演进时间轴

### 🚀 Phase 3.2: 细节致胜与布局优化 (Refining Gemini Experience & Layout)
**周期:** 2026-02-03 (v3.0.0.25)

#### 1. 触发逻辑的精准化 (Trigger Precision)
*   **背景**: 用户反馈在新建或保存个人 Gem 时，插件会误触发“自动固定共享 Gem”的逻辑，导致侧边栏数据冗余。
*   **方案**: 引入 URL 参数校验。
*   **技术实现**: 仅当 URL 包含 `usp=sharing` 时才启动自动 Pin 逻辑。这确保了“程序自动化”与“用户意图”的高度对齐。

#### 2. 侧边栏布局的深度调优 (Sidebar Layout Optimization)
*   **背景**: 插件注入的“共享 Gem”列表在特定分辨率下会出现显示限制（如仅显示2行），并挤压了原生 Gem 列表。
*   **方案**: 
    *   **打破高度枷锁**: 在 CSS 中强制设置 `max-height: none` 和 `overflow: visible`，确保列表项完整呈现。
    *   **语义化布局回归**: 将共享 Gem 列表从横向胶囊（Capsule）改为垂直列表（List），交互逻辑与原生侧边栏对齐。
    *   **空间压缩**: 减小插件容器的垂直 Margin，为原生内容留出更多呼吸空间。

#### 3. 手动干预机制 (Manual Override)
*   **功能**: 在共享页面增加“+ 固定当前 Gem”按钮。
*   **意义**: 即使在自动检测失败的极端情况下，用户仍能通过一次点击完成收藏，增强了系统的鲁棒性。

---

### 🚀 Phase 3.1: 细节致胜与共享生态 (Refining Gemini Experience)
**周期:** 2026-01-27 ~ 2026-02-01 (v3.0.0.16 - v3.0.0.20)

#### 1. 共享 Gem 收藏攻坚战 (Shared Gems Management)
*   **背景**: 用户希望将外部共享的 Gem 链接持久化存储在侧边栏，避免重复打开离线 URL。
*   **技术困难**: 
    *   **SPA 异步渲染**: Gemini 的页面标题和内容是分步加载的，插件往往在页面渲染出真实名称前就抓取了默认的 "Gemini" 或 "Chat"。
    *   **DOM 结构多变**: 共享页面的 DOM 与主应用页面存在细微差异，常规选择器容易失效。
*   **方案博弈**: 
    *   *方案 A (手动固定)*: 在页面注入按钮，由用户决定何时抓取。优点是准确，缺点是交互繁琐。
    *   *方案 B (自动监听)*: 使用 MutationObserver 实时监听。优点是自动化，但容易产生脏数据。
*   **最终决策**: 实施 **“自动固定 + 自我纠错”** 逻辑。
    *   **逻辑**: 插件自动抓取名称，如果发现抓取到的是 generic 词汇（如 "Gemini"），则标记为待更新。一旦探测到真实名称（如“医药代表 Kevin”），立即覆盖旧数据。
    *   **多源提取**: 同时监听 DOM 动画容器和 `document.title`，以应对不同的渲染时机。

#### 2. 布局自愈与 UI 稳定性
*   **困难**: 刷新页面时，文件夹 UI 偶尔会错位到 Gems 列表上方，破坏了 `Gems -> Folders -> Chats` 的垂直语义。
*   **方案**: 引入 `ensureFolderPosition` 机制。通过 `compareDocumentPosition` API 实时监测兄弟节点的顺序，一旦发现错位，立即利用原生 DOM 操作进行“物理归位”。
*   **成效**: 确保了在高度动态的侧边栏环境中，插件 UI 始终保持位置稳固。

### 🚀 Phase 3.2: 持续交付与版本同步 (Continuous Delivery)
**周期:** 2026-02-03 (v3.0.0.24)

#### 1. 代码库同步 (Codebase Sync)
*   **动作**: 将主开发分支与最新的 v3.0.0.24 发行版代码（Beta 4）完成同步。
*   **改进**: 引入了更灵敏的 Gemini 路由监听（1s 轮询）和更完善的名称抓取逻辑。
*   **交付**: 生成 `google-ai-companion-v3.0.0.24.zip` 供内部全量分发。

---

### 🚀 Phase 3: 跨平台融合 (Gemini Integration)
**周期:** 2026-01-24 ~ 2026-01-26 (v3.0.0.0 - v3.0.0.15)

#### 1. 注入策略的重大回滚 (The "Fixed vs Absolute" Saga)
*   **背景**: Gemini 的 DOM 结构没有稳定的滚动容器，初期尝试将 Timeline 注入 `document.body`。
*   **技术冲突**: 使用 `position: fixed` 配合 JS 动态计算位置来模拟跟随效果。
*   **失败分析**: 
    *   **性能损耗**: 频繁的滚动监听和重绘导致页面卡顿。
    *   **Z-Index 战争**: Fixed 元素极易被 Gemini 的各类 Overlay 遮挡。
*   **最终方案**: **回归 Parent Injection 架构**。
    *   **决策**: 宁可花时间寻找深层嵌套的父容器，也要利用 CSS 原生布局。
    *   **核心**: 强制父容器 `position: relative`，子元素 `position: absolute`。这证明了在复杂的第三方网页中，原生的 CSS 布局逻辑远比 JS 模拟更健壮。

#### 2. 事件门控与死循环屏蔽 (Event Gating)
*   **困难**: 在实现“全选”功能时，点击操作触发了 DOM 属性变化，进而触发了 `MutationObserver`，导致了“操作 -> 响应 -> 再次操作”的无限死循环。
*   **方案**: 引入 `isProgrammaticClick` 状态锁。
    *   在插件执行自动化操作时，先锁定状态，屏蔽所有内部监听器。
    *   操作完成后再释放锁。
*   **教训**: 在监听第三方 DOM 变动的插件中，明确区分“用户操作”与“程序操作”是确保稳定性的前置条件。

---

### 🛠 Phase 2: NotebookLM 深度优化 (Refinement)
**周期:** 2026-01-22 ~ 2026-01-24 (v2.1.18 - v2.1.26)

#### 1. 时间轴 (Timeline) 的视觉语言
*   **决策**: 将时间轴的指示点从圆点改为“向左的小三角”。
*   **理由**: 提供更强的语义暗示，指引用户视觉向左侧内容区对齐。
*   **Tooltip 优化**: 经历了从固定宽度到 `max-content` 自适应宽度的迭代，解决了文字溢出和排版拥挤的问题。

#### 2. 全能 Source 支持与抽象层
*   **背景**: 原有逻辑仅支持表格形式的 Source，导致 YouTube、PDF 等特殊容器被忽略。
*   **方案**: 创建 `getAllSourceRows()` 抽象辅助函数。
    *   它将 `.row` 和 `.single-source-container` 视为对等实体进行处理。
*   **价值**: 实现了 100% 的 Source 类型覆盖，为后续的批量操作打下了基础。

#### 3. 专注模式 (Focus Mode)
*   **设计逻辑**: 在批量操作时，通过 CSS 类名强制弱化原生 UI 的干扰（降低原生 Checkbox 透明度）。
*   **交互升级**: 实现“全域点击”，点击行的任何位置均可切换选中状态，极大提升了大量文件整理的效率。

---

### 🌱 Phase 1: MVP 原型与核心架构 (Foundation)
**周期:** 2026-01-22 之前

#### 1. 数据存储与同步策略
*   **决策**: 放弃了复杂的双向数据绑定框架，选择了“Checkbox-First”的同步协议。
*   **逻辑**: 插件的 UI 状态（是否选中）严格映射到原生的 Checkbox 状态。这确保了在 NotebookLM 内部逻辑发生变化时，插件的操作依然是合法的。

#### 2. 文件夹逻辑的建立
*   **数据隔离**: 实现了基于 Notebook ID 的命名空间隔离，解决了不同笔记本间数据污染的问题。
*   **SPA 监听**: 建立了对 URL 变化的全局监听，解决了单页应用切换笔记本时不刷新的痛点。

---

## 📚 技术原则与方法论总结

1.  **单一真理源 (Single Source of Truth)**:
    *   进度管理：以 `todo.json` 为准。
    *   UI 同步：以原生 Checkbox 状态为准。
2.  **防御性编程 (Defensive Programming)**:
    *   在注入任何 UI 元素前，必须进行容器存在性检查。
    *   使用 `try-catch` 包裹所有不稳定的 DOM 提取逻辑。
3.  **诊断日志优先 (Diagnostics First)**:
    *   在盲目修改代码前，先建立标准化的日志系统（如 `[Name-Search]`），通过数据反馈来指导修复。
4.  **原生融合感 (Native Integration)**:
    *   所有的 UI 设计（如磨砂背景、三点菜单、全宽列表）均以“看起来像原生功能”为最高标准。

---

## 🚩 遗留挑战与未来展望
*   **Gem 名称抓取**: 虽然已实现 90% 的覆盖率，但在网络极其缓慢的情况下，仍可能抓取到中间状态名称。
*   **多端同步**: 目前数据存储在 `chrome.storage.local`，未来可考虑同步至 `chrome.storage.sync` 实现跨设备共享。
