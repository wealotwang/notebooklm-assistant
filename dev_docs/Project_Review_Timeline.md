# Google AI Companion: 项目全景复盘与技术白皮书

本文档是对 Google AI Companion 项目（原 NotebookLM 文件夹工具）的深度客观复盘。它记录了从 MVP 原型到跨平台（NotebookLM & Gemini）深度融合过程中的核心决策、技术攻坚及经验教训。

---

## 📅 核心演进时间轴

### 🚀 Phase 3.9: 异步数据加载与判定加固 (Async Data & Strict Rules)
**周期:** 2026-02-03 (v3.0.0.33)

#### 1. 异步数据竞争的终结 (Ending Data Race)
*   **挑战**: 之前版本中，UI 注入 (`injectFolderUI`) 与数据加载 (`loadData`) 是并行执行的。由于 `chrome.storage.local.get` 是异步的，往往 UI 渲染完了数据还没回来，导致列表为空，直到用户手动操作触发重绘。
*   **修复**: 重构初始化流程，引入 Promise 链式调用。强制要求 **Data First, UI Second**——即只有当数据完全加载到内存后，才允许 UI 注入逻辑启动。

#### 2. 共享判定逻辑的净化 (Purifying Shared Logic)
*   **挑战**: 之前为了应对 URL 清洗引入了复杂的 Session 清理逻辑，导致在页面快速跳转时状态丢失，固定按钮时有时无。同时，对于非共享链接的判定不够严格。
*   **修复**: 
    *   **移除不稳定逻辑**: 删除了自动清理 Session 的代码，让状态更持久。
    *   **优先级明确**: URL 中的 `usp=sharing` 是最高优先级信号。
    *   **兜底机制**: 增加最后一道防线，如果 URL 无参数且 Session 无记录，强制隐藏按钮，彻底解决误触发问题。

---

### 🚀 Phase 3.8: 响应式折叠与稳健渲染 (Responsive Collapse & Robust Rendering)
**周期:** 2026-02-03 (v3.0.0.31)

#### 1. 响应式折叠模式 (Responsive Collapse Mode)
*   **挑战**: 简单的“隐藏”策略在 Gemini 复杂的 SPA 环境下容易失效；而“始终显示”策略在侧边栏收起时会导致文字溢出，影响美观。
*   **方案**: 引入智能类名切换 (`.sidebar-collapsed`)。
    *   **JS 层**: 使用 `ResizeObserver` 实时监测侧边栏宽度。当宽度小于 150px 时，给容器添加折叠类。
    *   **CSS 层**: 针对折叠状态，隐藏所有文字标签（Title, Item Name），仅保留图标，并调整 Padding。
    *   **效果**: 实现了“收起即变图标栏”的原生级体验，既保留了功能入口，又彻底解决了文字溢出问题。

#### 2. 渲染流程的终极加固 (Render Stability)
*   **挑战**: 在路由切换或页面刷新时，UI 骨架注入成功但内容为空（幽灵列表）。这是因为数据渲染函数未能在所有注入场景下被触发。
*   **修复**: 在 `injectFolderUI` 的生命周期末尾，增加**强制渲染指令**。无论 UI 是通过初始化还是 MutationObserver 注入，最后一步永远是 `renderSharedGems()` 和 `renderFolders()`。
*   **调试**: 引入 `DOMService.log`，在渲染核心路径上输出关键数据状态，让未来的排查不再盲目。

---

### 🚀 Phase 3.7: 战略性回退 (Strategic Rollback)
**周期:** 2026-02-03 (v3.0.0.30)

#### 1. 侧边栏自动隐藏逻辑回退 (Sidebar Auto-Hide Revert)
*   **背景**: v27 引入的“侧边栏收起时自动隐藏插件 UI”功能，在实际运行中因 Gemini 容器宽度的动态变化（特别是新标签页加载时），频繁导致误判，使用户看到空白区域。
*   **决策**: 听取用户反馈，果断回退该逻辑。现在插件 UI 恢复为 v26 的行为——**始终尝试显示**。
*   **权衡**: 虽然这意味着在极窄侧边栏下可能会有轻微的 UI 溢出，但这远比“完全看不见功能”要好。我们优先保证功能的可用性 (Availability)。

---

### 🚀 Phase 3.6: 渲染时机的精准把控 (Rendering Timing)
**周期:** 2026-02-03 (v3.0.0.29)

#### 1. 消除“幽灵列表” (Fixing Ghost List)
*   **现象**: 用户反馈在刷新页面或路由跳转后，文件夹列表 UI 成功注入，但内容为空，直到点击“+”按钮触发重绘才出现。
*   **根源**: `injectFolderUI` 仅负责 DOM 骨架搭建，但在 `MutationObserver` 触发的动态注入场景下，缺少了后续的数据填充指令 (`renderFolders`)。
*   **修复**: 在 UI 注入的生命周期末尾，强制链式调用渲染函数。确保“骨架”与“血肉”同步就位，消除视觉上的空窗期。

---

### 🚀 Phase 3.5: 隐形状态的持久化 (State Persistence)
**周期:** 2026-02-03 (v3.0.0.28)

#### 1. 攻克 URL 清洗难题 (Fixing URL Cleaning)
*   **挑战**: Gemini SPA 在加载后会自动清洗 URL（移除 `usp=sharing` 参数），导致插件仅依赖 URL 检测共享状态的逻辑失效。这使用户在打开共享链接后，插件 UI 却无任何反应。
*   **破局**: 引入 **Session Storage 状态保持机制**。
    *   **捕捉**: 插件在页面加载瞬间捕获 `usp=sharing` 信号，并将 Gem ID 存入 Session。
    *   **持久化**: 即使 URL 随后变得“纯净”，渲染引擎也会读取 Session 记录，坚定地显示“+ 固定当前 Gem”按钮。
    *   **自毁**: 一旦用户导航离开该 Gem，状态自动清除，确保逻辑的严谨性。

---

### 🚀 Phase 3.4: 引导与适配的最后一公里 (Onboarding & Responsiveness)
**周期:** 2026-02-03 (v3.0.0.27)

#### 1. 新用户引导 (Onboarding UX)
*   **痛点**: 用户初次固定共享 Gem 时，如果名字抓取失败（显示为空或 Generic Name），会感到困惑。
*   **优化**: 引入了智能占位符机制。当探测到无效名称时，直接显示 **"📝 点击重命名"**，并用斜体样式区分。这不仅是提示，更是一种行动号召 (Call to Action)，引导用户建立自己的命名秩序。

#### 2. 侧边栏响应式适配 (Responsive Sidebar)
*   **痛点**: 在新标签页打开 Gemini 时，侧边栏默认收起，但插件 UI 却强制展开，导致布局穿模。
*   **技术方案**: 
    *   **实时侦测**: 引入了更灵敏的 `checkSidebar` 逻辑，结合 `ResizeObserver` 实时监听父容器宽度。
    *   **阈值控制**: 设定 `150px` 为安全阈值。一旦侧边栏收起（宽度通常 < 80px），插件 UI 自动隐藏，待展开后再优雅浮现。

#### 3. 语义化微调 (Copy Polish)
*   **细节**: 将原本宽泛的“文件夹分类”更名为 **“Chats 文件夹分类”**，与下方 Gemini 的 "Chats" 列表形成更紧密的语义对应。

---

### 🚀 Phase 3.3: 交互体验的回归与升华 (Native UI & Renaming)
**周期:** 2026-02-03 (v3.0.0.26)

#### 1. 原生 UI 的回归 (The Return of Capsule UI)
*   **背景**: v25 尝试改用普通列表样式以解决空间问题，但牺牲了 Gemini 独特的设计美感。用户明确表示更偏爱 v24 的“胶囊”风格。
*   **决策**: 听取用户反馈，**全量移植 v24 的 UI 样式**。
*   **细节**: 恢复 `100px` 大圆角、悬停时的浅灰背景以及左右对齐的精细 Padding，确保插件注入的模块在视觉上与 Gemini 原生模块浑然一体，不再有“异物感”。

#### 2. 重命名能力的补全 (Renaming Capability)
*   **背景**: 自动抓取的 Gem 名称有时不准确（如 "Chats"），且 v25 缺乏后期修改的手段。
*   **方案**: 
    *   **右键重命名**: 在 Gem 的上下文菜单中新增“重命名”选项。
    *   **智能手动固定**: 点击“+ 固定当前 Gem”时，不再盲目自动保存，而是**弹出输入框**，让用户拥有最终决定权。

#### 3. 垃圾数据防火墙 (Anti-Spam Filter)
*   **优化**: 在自动抓取逻辑中，强制屏蔽了 "Chats" 和 "Chat" 等无效关键词。如果探测到这些名字，插件会拒绝自动固定，直到用户手动输入有效名称。

---

### 🚀 Phase 3.2: 细节致胜与布局优化 (Refining Gemini Experience & Layout)
**周期:** 2026-02-03 (v3.0.0.25)

#### 1. 触发逻辑的精准化 (Trigger Precision)
*   **背景**: 用户反馈在新建或保存个人 Gem 时，插件会误触发“自动固定共享 Gem”的逻辑，导致侧边栏数据冗余。
*   **方案**: 引入 URL 参数校验。
*   **技术实现**: 仅当 URL 包含 `usp=sharing` 时才启动自动 Pin 逻辑。这确保了“程序自动化”与“用户意图”的高度对齐。

#### 2. 侧边栏布局的深度调优 (Sidebar Layout Optimization)
*   **背景**: 插件注入的“共享 Gem”列表在特定分辨率下会出现显示限制（如仅显示2行），并挤压了原生 Gem 列表。
*   **方案**: 
    *   **打破高度枷锁**: 在 CSS 中强制设置 `max-height: none` 和 `overflow: visible`，确保列表项完整呈现。
    *   **语义化布局回归**: 将共享 Gem 列表从横向胶囊（Capsule）改为垂直列表（List），交互逻辑与原生侧边栏对齐。
    *   **空间压缩**: 减小插件容器的垂直 Margin，为原生内容留出更多呼吸空间。

#### 3. 手动干预机制 (Manual Override)
*   **功能**: 在共享页面增加“+ 固定当前 Gem”按钮。
*   **意义**: 即使在自动检测失败的极端情况下，用户仍能通过一次点击完成收藏，增强了系统的鲁棒性。

---

### 🚀 Phase 3.1: 细节致胜与共享生态 (Refining Gemini Experience)
**周期:** 2026-01-27 ~ 2026-02-01 (v3.0.0.16 - v3.0.0.20)

#### 1. 共享 Gem 收藏攻坚战 (Shared Gems Management)
*   **背景**: 用户希望将外部共享的 Gem 链接持久化存储在侧边栏，避免重复打开离线 URL。
*   **技术困难**: 
    *   **SPA 异步渲染**: Gemini 的页面标题和内容是分步加载的，插件往往在页面渲染出真实名称前就抓取了默认的 "Gemini" 或 "Chat"。
    *   **DOM 结构多变**: 共享页面的 DOM 与主应用页面存在细微差异，常规选择器容易失效。
*   **方案博弈**: 
    *   *方案 A (手动固定)*: 在页面注入按钮，由用户决定何时抓取。优点是准确，缺点是交互繁琐。
    *   *方案 B (自动监听)*: 使用 MutationObserver 实时监听。优点是自动化，但容易产生脏数据。
*   **最终决策**: 实施 **“自动固定 + 自我纠错”** 逻辑。
    *   **逻辑**: 插件自动抓取名称，如果发现抓取到的是 generic 词汇（如 "Gemini"），则标记为待更新。一旦探测到真实名称（如“医药代表 Kevin”），立即覆盖旧数据。
    *   **多源提取**: 同时监听 DOM 动画容器和 `document.title`，以应对不同的渲染时机。

#### 2. 布局自愈与 UI 稳定性
*   **困难**: 刷新页面时，文件夹 UI 偶尔会错位到 Gems 列表上方，破坏了 `Gems -> Folders -> Chats` 的垂直语义。
*   **方案**: 引入 `ensureFolderPosition` 机制。通过 `compareDocumentPosition` API 实时监测兄弟节点的顺序，一旦发现错位，立即利用原生 DOM 操作进行“物理归位”。
*   **成效**: 确保了在高度动态的侧边栏环境中，插件 UI 始终保持位置稳固。

### 🚀 Phase 3.2: 持续交付与版本同步 (Continuous Delivery)
**周期:** 2026-02-03 (v3.0.0.24)

#### 1. 代码库同步 (Codebase Sync)
*   **动作**: 将主开发分支与最新的 v3.0.0.24 发行版代码（Beta 4）完成同步。
*   **改进**: 引入了更灵敏的 Gemini 路由监听（1s 轮询）和更完善的名称抓取逻辑。
*   **交付**: 生成 `google-ai-companion-v3.0.0.24.zip` 供内部全量分发。

---

### 🚀 Phase 3: 跨平台融合 (Gemini Integration)
**周期:** 2026-01-24 ~ 2026-01-26 (v3.0.0.0 - v3.0.0.15)

#### 1. 注入策略的重大回滚 (The "Fixed vs Absolute" Saga)
*   **背景**: Gemini 的 DOM 结构没有稳定的滚动容器，初期尝试将 Timeline 注入 `document.body`。
*   **技术冲突**: 使用 `position: fixed` 配合 JS 动态计算位置来模拟跟随效果。
*   **失败分析**: 
    *   **性能损耗**: 频繁的滚动监听和重绘导致页面卡顿。
    *   **Z-Index 战争**: Fixed 元素极易被 Gemini 的各类 Overlay 遮挡。
*   **最终方案**: **回归 Parent Injection 架构**。
    *   **决策**: 宁可花时间寻找深层嵌套的父容器，也要利用 CSS 原生布局。
    *   **核心**: 强制父容器 `position: relative`，子元素 `position: absolute`。这证明了在复杂的第三方网页中，原生的 CSS 布局逻辑远比 JS 模拟更健壮。

#### 2. 事件门控与死循环屏蔽 (Event Gating)
*   **困难**: 在实现“全选”功能时，点击操作触发了 DOM 属性变化，进而触发了 `MutationObserver`，导致了“操作 -> 响应 -> 再次操作”的无限死循环。
*   **方案**: 引入 `isProgrammaticClick` 状态锁。
    *   在插件执行自动化操作时，先锁定状态，屏蔽所有内部监听器。
    *   操作完成后再释放锁。
*   **教训**: 在监听第三方 DOM 变动的插件中，明确区分“用户操作”与“程序操作”是确保稳定性的前置条件。

---

### 🛠 Phase 2: NotebookLM 深度优化 (Refinement)
**周期:** 2026-01-22 ~ 2026-01-24 (v2.1.18 - v2.1.26)

#### 1. 时间轴 (Timeline) 的视觉语言
*   **决策**: 将时间轴的指示点从圆点改为“向左的小三角”。
*   **理由**: 提供更强的语义暗示，指引用户视觉向左侧内容区对齐。
*   **Tooltip 优化**: 经历了从固定宽度到 `max-content` 自适应宽度的迭代，解决了文字溢出和排版拥挤的问题。

#### 2. 全能 Source 支持与抽象层
*   **背景**: 原有逻辑仅支持表格形式的 Source，导致 YouTube、PDF 等特殊容器被忽略。
*   **方案**: 创建 `getAllSourceRows()` 抽象辅助函数。
    *   它将 `.row` 和 `.single-source-container` 视为对等实体进行处理。
*   **价值**: 实现了 100% 的 Source 类型覆盖，为后续的批量操作打下了基础。

#### 3. 专注模式 (Focus Mode)
*   **设计逻辑**: 在批量操作时，通过 CSS 类名强制弱化原生 UI 的干扰（降低原生 Checkbox 透明度）。
*   **交互升级**: 实现“全域点击”，点击行的任何位置均可切换选中状态，极大提升了大量文件整理的效率。

---

### 🌱 Phase 1: MVP 原型与核心架构 (Foundation)
**周期:** 2026-01-22 之前

#### 1. 数据存储与同步策略
*   **决策**: 放弃了复杂的双向数据绑定框架，选择了“Checkbox-First”的同步协议。
*   **逻辑**: 插件的 UI 状态（是否选中）严格映射到原生的 Checkbox 状态。这确保了在 NotebookLM 内部逻辑发生变化时，插件的操作依然是合法的。

#### 2. 文件夹逻辑的建立
*   **数据隔离**: 实现了基于 Notebook ID 的命名空间隔离，解决了不同笔记本间数据污染的问题。
*   **SPA 监听**: 建立了对 URL 变化的全局监听，解决了单页应用切换笔记本时不刷新的痛点。

---

## 📚 技术原则与方法论总结

1.  **单一真理源 (Single Source of Truth)**:
    *   进度管理：以 `todo.json` 为准。
    *   UI 同步：以原生 Checkbox 状态为准。
2.  **防御性编程 (Defensive Programming)**:
    *   在注入任何 UI 元素前，必须进行容器存在性检查。
    *   使用 `try-catch` 包裹所有不稳定的 DOM 提取逻辑。
3.  **诊断日志优先 (Diagnostics First)**:
    *   在盲目修改代码前，先建立标准化的日志系统（如 `[Name-Search]`），通过数据反馈来指导修复。
4.  **原生融合感 (Native Integration)**:
    *   所有的 UI 设计（如磨砂背景、三点菜单、全宽列表）均以“看起来像原生功能”为最高标准。

---

## 🚩 遗留挑战与未来展望
*   **Gem 名称抓取**: 虽然已实现 90% 的覆盖率，但在网络极其缓慢的情况下，仍可能抓取到中间状态名称。
*   **多端同步**: 目前数据存储在 `chrome.storage.local`，未来可考虑同步至 `chrome.storage.sync` 实现跨设备共享。
