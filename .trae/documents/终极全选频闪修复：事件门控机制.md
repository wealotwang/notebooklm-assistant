# 终极修复：彻底解决全选频闪 (The "Phantom Trigger" Fix)

## 1. 深度复盘 (Post-Mortem)
*   **现象**: 即便移除了 `attributes` 监听，Log 依然显示 `Triggering View sync from Native changes...` 在疯狂刷屏（每秒多次）。
*   **根本原因**: NotebookLM 的原生 Checkbox 在被我们代码点击（`safeClick` -> `element.click()`）时，会触发原生的 `change` 事件。而我们新加的 `change` 监听器捕获了这个事件，再次调用 `syncViewFromNative`，再次点击 Checkbox... 形成了新的死循环：
    *   `Plugin Clicks Native Checkbox` -> `Native Checkbox 'change' Event` -> `Our Listener` -> `Sync Logic` -> `Plugin Clicks Native Checkbox` -> ...
*   **为何之前没发现**: 之前主要怀疑是 Observer 监听属性变化太快，现在发现即使是 Event Listener，如果不区分“人为点击”和“代码点击”，依然会死循环。

## 2. 解决方案：Event Gating (事件门控)
我们需要一种机制来区分 **"用户真实点击"** 和 **"插件代码点击"**。

### 策略 A: 临时 Flag 锁 (简单有效)
1.  定义全局标志位 `state.isSyncingToNative = false`。
2.  在插件代码执行 `safeClick` 前，设置 `state.isSyncingToNative = true`。
3.  在 `safeClick` 后（或 `setTimeout(..., 0)` 后），重置为 `false`。
4.  在 `change` 事件监听器中，检查 `state.isSyncingToNative`。如果是 `true`，说明是自己触发的，直接 **return**，不执行反向同步。

### 策略 B: 移除 `change` 监听，仅依靠 Observer 的结构变化
*   如果我们完全移除 `change` 监听，只在打开详情视图时同步一次，那么如果用户在详情视图打开的情况下，去点了原生列表的复选框，详情视图不会更新。这不可接受。

### 决定采用：策略 A + 防抖增强
1.  **Flag Lock**: 引入 `state.isProgrammaticClick`。
2.  **Debounce**: 增加防抖时间到 100ms。
3.  **Scoped Sync**: 只有当 `activeFolderId !== 'all'` 时才需要如此高频同步。

## 3. 执行计划
1.  修改 `content_notebooklm.js`：
    *   在 `state` 中增加 `isProgrammaticClick`。
    *   在 `syncSingleFileToNative` 中，包裹 `safeClick` 调用，设置 Flag。
    *   在 `setupNativeCheckboxListener` 中，检查 Flag，如果为 true 则忽略。
    *   **额外保险**: 检查 `e.isTrusted`。虽然 `element.click()` 触发的事件通常 `isTrusted` 为 false，但某些框架模拟的点击可能很难区分。我们将优先使用 `isTrusted` 检查，辅以 Flag。

## 4. 版本更新
*   Manifest -> `3.0.0.14`
*   Changelog -> 更新 Fix 记录。
